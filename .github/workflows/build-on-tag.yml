name: 🏗️ Build Executables on Version Tag

# Triggers automatically when you push a version tag (e.g., v6.1.0, v6.2.0, v7.0.0)
on:
  push:
    tags:
      - 'v*.*.*'  # Matches v6.1.0, v6.2.1, v7.0.0, etc.

permissions:
  contents: write
  actions: read

jobs:
  detect-version:
    name: 🔍 Detect Version & Generate Spec File
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      version_number: ${{ steps.get_version.outputs.version_number }}
      version_short: ${{ steps.get_version.outputs.version_short }}
      spec_file: ${{ steps.get_version.outputs.spec_file }}
      
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
    
    - name: 🔍 Extract version and generate spec file
      id: get_version
      run: |
        # Tag is like refs/tags/v6.3.0
        TAG_NAME="${GITHUB_REF#refs/tags/}"
        VERSION_NUMBER="${TAG_NAME#v}"  # Remove 'v' prefix (e.g., "6.3.0")
        
        # Extract major.minor for spec naming (e.g., "6.3" from "6.3.0")
        VERSION_SHORT=$(echo "$VERSION_NUMBER" | cut -d. -f1,2)
        
        # Generate spec file from template
        SPEC_FILE="DocMiner${VERSION_SHORT}.spec"
        
        echo "📌 Building version: $TAG_NAME ($VERSION_NUMBER)"
        echo "📝 Generating spec file: $SPEC_FILE"
        
        # Replace placeholders in template
        sed "s/{{VERSION}}/${VERSION_NUMBER}/g; s/{{VERSION_SHORT}}/${VERSION_SHORT}/g" \
          build_files/DocMiner.spec.template > "build_files/${SPEC_FILE}"
        
        echo "✅ Generated spec file: build_files/${SPEC_FILE}"
        
        # Output values
        echo "version=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
        echo "version_short=$VERSION_SHORT" >> $GITHUB_OUTPUT
        echo "spec_file=$SPEC_FILE" >> $GITHUB_OUTPUT

  build:
    name: 🔨 Build ${{ matrix.platform }}
    needs: detect-version
    strategy:
      matrix:
        include:
          # - os: ubuntu-20.04
          #   platform: Linux
          #   artifact_name: DocMiner-linux
          - os: windows-latest
            platform: Windows
            artifact_name: DocMiner-windows
          - os: macos-13
            platform: macOS
            artifact_name: DocMiner-macos

    runs-on: ${{ matrix.os }}
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
    
    - name: 🐍 Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: 📦 Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller
    
    - name: 🔨 Build executable
      run: |
        python -m PyInstaller build_files/${{ needs.detect-version.outputs.spec_file }} --distpath ./dist --workpath ./build --clean --noconfirm
    
    - name: 🍎 Setup macOS code signing (macOS only)
      if: matrix.platform == 'macOS'
      run: |
        # Import certificate from secrets
        echo "${{ secrets.APPLE_CERTIFICATE_P12 }}" | base64 --decode > certificate.p12
        
        # Create temporary keychain
        security create-keychain -p actions build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p actions build.keychain
        security set-keychain-settings -t 3600 -u build.keychain
        
        # Import certificate
        security import certificate.p12 -k build.keychain -P "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple: -s -k actions build.keychain
        
        # Download Apple intermediate certificate
        curl -o DeveloperIDG2CA.cer https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer
        security import DeveloperIDG2CA.cer -k build.keychain -T /usr/bin/codesign
        
        # Verify certificate is available
        security find-identity -v -p codesigning
        
        # Clean up
        rm certificate.p12 DeveloperIDG2CA.cer
    
    - name: 🔏 Code sign app bundle (macOS only)
      if: matrix.platform == 'macOS'
      run: |
        SPEC_BASE=$(basename "${{ needs.detect-version.outputs.spec_file }}" .spec)
        APP_PATH="dist/${SPEC_BASE}.app"
        
        # Sign the app bundle
        codesign --deep --force --verify --verbose \
          --sign "Developer ID Application: Michael Edwards (PQF3LP3FR2)" \
          --options runtime \
          --entitlements build_files/entitlements.plist \
          "$APP_PATH"
        
        # Verify signature
        codesign --verify --verbose=4 "$APP_PATH"
        echo "✅ App bundle signed successfully"
    
    - name: 📁 Prepare release files
      shell: bash
      run: |
        VERSION_NUM="${{ needs.detect-version.outputs.version_number }}"
        
        # Extract app name from spec file (e.g., DocMiner6.1 from DocMiner6.1.spec)
        SPEC_BASE=$(basename "${{ needs.detect-version.outputs.spec_file }}" .spec)
        
        mkdir -p release-files
        
        if [ "${{ matrix.platform }}" == "Windows" ]; then
          cd dist/${SPEC_BASE}
          powershell -Command "Compress-Archive -Path * -DestinationPath ../../release-files/DocMiner-${VERSION_NUM}-Windows.zip"
        elif [ "${{ matrix.platform }}" == "macOS" ]; then
          # Create DMG
          hdiutil create -volname "DocMiner ${VERSION_NUM}" \
            -srcfolder "dist/${SPEC_BASE}.app" \
            -ov -format UDZO \
            "DocMiner-${VERSION_NUM}-macOS.dmg"
          
          # Sign the DMG
          codesign --force --sign "Developer ID Application: Michael Edwards (PQF3LP3FR2)" \
            "DocMiner-${VERSION_NUM}-macOS.dmg"
          
          echo "✅ DMG created and signed"
          
          # Notarize the DMG
          echo "📤 Submitting DMG for notarization..."
          xcrun notarytool submit "DocMiner-${VERSION_NUM}-macOS.dmg" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_APP_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait
          
          # Staple notarization ticket
          echo "📎 Stapling notarization ticket..."
          xcrun stapler staple "DocMiner-${VERSION_NUM}-macOS.dmg"
          
          # Verify stapling
          xcrun stapler validate "DocMiner-${VERSION_NUM}-macOS.dmg"
          
          echo "✅ DMG notarized and stapled successfully"
          
          # Move to release files
          mv "DocMiner-${VERSION_NUM}-macOS.dmg" release-files/
        else
          # Linux - create both tar.gz and try AppImage
          cd dist
          tar -czf ../release-files/DocMiner-${VERSION_NUM}-Linux.tar.gz ${SPEC_BASE}/
          
          # Build AppImage if script exists
          if [ -f "../build_files/create_appimage.sh" ]; then
            cd ..
            bash build_files/create_appimage.sh || echo "AppImage build failed, continuing..."
            mv DocMiner-*-x86_64.AppImage release-files/ 2>/dev/null || true
          fi
        fi
    
    - name: 📤 Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: release-files/*
        retention-days: 7

  release:
    name: 🎉 Create GitHub Release
    needs: [detect-version, build]
    runs-on: ubuntu-latest
    
    steps:
    - name: 📥 Checkout code (for release notes)
      uses: actions/checkout@v4
    
    - name: 📥 Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: 📋 Consolidate release files
      run: |
        mkdir -p release-files
        find artifacts -type f -exec cp {} release-files/ \;
        ls -lh release-files/
    
    - name: 📝 Check for release notes
      id: check_notes
      run: |
        VERSION_NUM="${{ needs.detect-version.outputs.version_number }}"
        NOTES_FILE="RELEASE_NOTES_v${VERSION_NUM}.txt"
        
        if [ -f "$NOTES_FILE" ]; then
          echo "has_notes=true" >> $GITHUB_OUTPUT
          echo "notes_file=$NOTES_FILE" >> $GITHUB_OUTPUT
          echo "✅ Found release notes: $NOTES_FILE"
        else
          echo "has_notes=false" >> $GITHUB_OUTPUT
          echo "ℹ️  No release notes file found (looked for $NOTES_FILE)"
        fi
    
    - name: 🎉 Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.detect-version.outputs.version }}
        name: "DocMiner ${{ needs.detect-version.outputs.version }}"
        draft: false
        prerelease: false
        make_latest: true
        files: release-files/*
        body_path: ${{ steps.check_notes.outputs.has_notes == 'true' && steps.check_notes.outputs.notes_file || '' }}
        body: |
          # 🎯 DocMiner ${{ needs.detect-version.outputs.version }}
          
          **Automated release build**
          
          ## 📥 Quick Downloads
          
          - 🐧 **Linux**: `DocMiner-*-x86_64.AppImage` (recommended) or `DocMiner-*-Linux.tar.gz`
          - 🍎 **macOS**: `DocMiner-*-macOS.dmg` (Intel & Apple Silicon compatible)
          - 🪟 **Windows**: `DocMiner-*-Windows.zip`
          
          ## 📝 Installation
          
          ### Linux
          ```bash
          chmod +x DocMiner-*-x86_64.AppImage
          ./DocMiner-*-x86_64.AppImage
          ```
          
          ### macOS
          1. Download DMG
          2. Double-click to open
          3. Drag DocMiner to Applications
          4. If blocked by security: `xattr -cr /Applications/DocMiner*.app`
          
          ### Windows
          1. Download ZIP
          2. Extract all files
          3. Double-click `DocMiner*.exe`
          
          ---
          
          ${{ steps.check_notes.outputs.has_notes == 'true' && 'See detailed release notes above.' || 'Built from latest source code.' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
