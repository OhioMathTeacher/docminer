#!/usr/bin/env python3
"""
Build script for Research Buddy 5.1 executables
Supports Linux, Windows, and macOS builds with cross-platform CI/CD

Usage: 
    python build.py [platform] [--spec-file] [--clean]
    
Platforms: linux, windows, macos, all
Options:
    --spec-file: Use existing spec file instead of auto-generation
    --clean: Clean build directories before building
"""

import subprocess
import sys
import platform
import shutil
import argparse
from pathlib import Path
import os

VERSION = "5.1"
PROJECT_NAME = "ResearchBuddy"
MAIN_SCRIPT = "enhanced_training_interface.py"

def run_command(cmd, description, capture_output=True):
    """Run a command and handle errors gracefully"""
    print(f"üîÑ {description}...")
    try:
        if isinstance(cmd, list):
            cmd_str = " ".join(cmd)
        else:
            cmd_str = cmd
            
        result = subprocess.run(
            cmd_str, 
            shell=True, 
            check=True, 
            capture_output=capture_output, 
            text=True,
            cwd=Path(__file__).parent.parent  # Run from project root
        )
        print(f"‚úÖ {description} completed")
        if result.stdout and capture_output:
            print(f"   Output: {result.stdout.strip()}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå {description} failed:")
        print(f"   Command: {cmd_str}")
        if e.stderr:
            print(f"   Error: {e.stderr}")
        return False

def check_dependencies():
    """Check if required build tools are installed"""
    print("üîç Checking build dependencies...")
    
    deps = [
        ("python", "python3 --version"),
        ("pip", "pip3 --version"), 
        ("pyinstaller", "python3 -m PyInstaller --version")
    ]
    
    missing = []
    for name, cmd in deps:
        if not run_command(cmd, f"Checking {name}"):
            missing.append(name)
    
    if missing:
        print(f"‚ùå Missing dependencies: {', '.join(missing)}")
        print("üì¶ Install PyInstaller with: pip3 install pyinstaller")
        return False
    
    return True

def clean_build_dirs():
    """Clean previous build artifacts"""
    print("üßπ Cleaning build directories...")
    
    dirs_to_clean = ["build", "dist", "__pycache__", "*.egg-info"]
    
    for dir_pattern in dirs_to_clean:
        for path in Path(".").glob(f"**/{dir_pattern}"):
            if path.is_dir():
                shutil.rmtree(path, ignore_errors=True)
                print(f"   üóëÔ∏è Removed {path}")
            elif path.is_file():
                path.unlink(missing_ok=True)
                print(f"   üóëÔ∏è Removed {path}")

def install_requirements():
    """Install project requirements"""
    requirements_file = Path("requirements.txt")
    if requirements_file.exists():
        return run_command(
            "pip3 install -r requirements.txt",
            "Installing requirements"
        )
    else:
        print("‚ö†Ô∏è No requirements.txt found, skipping dependency installation")
        return True

def build_with_spec(spec_file, target_platform):
    """Build using existing spec file"""
    spec_path = Path("build_files") / spec_file
    
    if not spec_path.exists():
        print(f"‚ùå Spec file not found: {spec_path}")
        return False
    
    cmd = [
        "python3", "-m", "PyInstaller",
        str(spec_path),
        "--distpath", "./dist",
        "--workpath", "./build"
    ]
    
    return run_command(cmd, f"Building with spec file: {spec_file}")

def build_executable(target_platform, use_spec=False):
    """Build executable for specified platform"""
    if not target_platform:
        target_platform = platform.system().lower()
    
    print(f"üî® Building {PROJECT_NAME} {VERSION} for {target_platform}...")
    
    # Use spec file if requested
    if use_spec:
        spec_file = f"{PROJECT_NAME}{VERSION}.spec"
        return build_with_spec(spec_file, target_platform)
    
    # Auto-generate build command
    base_cmd = [
        "python3", "-m", "PyInstaller",
        "--onefile",
        "--windowed", 
        "--distpath", "./dist",
        "--workpath", "./build",
        "--name", f"{PROJECT_NAME}{VERSION}",
        "--add-data", "sample_pdfs:sample_pdfs",
        "--add-data", "README.md:.",
        "--add-data", "docs:docs", 
        "--add-data", "legal:legal",
        "--hidden-import", "utils.metadata_extractor",
        "--hidden-import", "PySide6.QtWebEngineWidgets",
        "--hidden-import", "fitz",
        "--hidden-import", "openai",
        "--exclude-module", "first_run_setup",
    ]
    
    # Platform-specific settings
    if target_platform == "darwin" or target_platform == "macos":
        base_cmd.extend([
            "--target-arch", "universal2",
            "--osx-bundle-identifier", "edu.university.researchbuddy"
        ])
    elif target_platform == "windows":
        base_cmd.extend([
            "--noconsole"  # No console window on Windows
        ])
    
    # Add main script
    base_cmd.append(MAIN_SCRIPT)
    
    # Run PyInstaller
    if run_command(base_cmd, f"Building {target_platform} executable"):
        print(f"üéâ Build completed for {target_platform}")
        
        # Show result
        dist_path = Path("./dist")
        if dist_path.exists():
            print(f"üì¶ Executable created in: {dist_path.absolute()}")
            for exe in dist_path.glob("*"):
                size_mb = exe.stat().st_size / (1024 * 1024)
                print(f"   üìÑ {exe.name} ({size_mb:.1f} MB)")
        
        return True
    else:
        print(f"‚ùå Build failed for {target_platform}")
        return False

def create_distribution_package(target_platform):
    """Create distribution package with documentation"""
    if not target_platform:
        target_platform = platform.system().lower()
    
    print(f"üì¶ Creating distribution package for {target_platform}...")
    
    # Create distribution directory
    dist_dir = Path("./releases")
    dist_dir.mkdir(exist_ok=True)
    
    platform_dir = dist_dir / f"{PROJECT_NAME}{VERSION}-{target_platform}"
    if platform_dir.exists():
        shutil.rmtree(platform_dir)
    platform_dir.mkdir(exist_ok=True)
    
    # Copy executable
    dist_path = Path("./dist")
    for exe in dist_path.glob("*"):
        if exe.is_file():
            shutil.copy2(exe, platform_dir)
            print(f"   ‚úÖ Copied {exe.name}")
    
    # Copy documentation
    docs = [
        "README.md",
        "docs/QUICK_START_FOR_GAS.md",
        "requirements.txt"
    ]
    
    for doc in docs:
        doc_path = Path(doc)
        if doc_path.exists():
            dest = platform_dir / doc_path.name
            dest.parent.mkdir(exist_ok=True)
            shutil.copy2(doc_path, dest)
            print(f"   ‚úÖ Copied {doc}")
    
    # Copy sample PDFs
    sample_dir = platform_dir / "sample_pdfs"
    sample_dir.mkdir(exist_ok=True)
    for pdf in Path("sample_pdfs").glob("*.pdf"):
        shutil.copy2(pdf, sample_dir)
        print(f"   ‚úÖ Copied {pdf.name}")
    
    # Create archive
    if target_platform == "windows":
        archive_name = f"{PROJECT_NAME}{VERSION}-{target_platform}"
        shutil.make_archive(str(dist_dir / archive_name), 'zip', platform_dir)
        print(f"   üì¶ Created {archive_name}.zip")
    else:
        archive_name = f"{PROJECT_NAME}{VERSION}-{target_platform}"
        shutil.make_archive(str(dist_dir / archive_name), 'gztar', platform_dir)
        print(f"   üì¶ Created {archive_name}.tar.gz")
    
    return True

def setup_github_actions():
    """Create GitHub Actions workflow for cross-platform builds"""
    workflow_dir = Path(".github/workflows")
    workflow_dir.mkdir(parents=True, exist_ok=True)
    
    workflow_content = '''name: Build Research Buddy Cross-Platform

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            artifact-name: ResearchBuddy5.1-linux
          - os: windows-latest  
            platform: windows
            artifact-name: ResearchBuddy5.1-windows
          - os: macos-latest
            platform: macos
            artifact-name: ResearchBuddy5.1-macos

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller
        
    - name: Build executable
      run: |
        cd build_files
        python build.py ${{ matrix.platform }} --spec-file
        
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.artifact-name }}
        path: releases/
'''
    
    workflow_file = workflow_dir / "build.yml"
    workflow_file.write_text(workflow_content)
    print(f"‚úÖ Created GitHub Actions workflow: {workflow_file}")

def main():
    """Main build script"""
    parser = argparse.ArgumentParser(description=f"Build {PROJECT_NAME} {VERSION} executables")
    parser.add_argument("platform", nargs="?", choices=["linux", "windows", "macos", "all"], 
                       help="Target platform (default: current platform)")
    parser.add_argument("--spec-file", action="store_true", 
                       help="Use existing spec file instead of auto-generation")
    parser.add_argument("--clean", action="store_true", 
                       help="Clean build directories before building")
    parser.add_argument("--setup-ci", action="store_true",
                       help="Setup GitHub Actions workflow")
    
    args = parser.parse_args()
    
    current_platform = platform.system().lower()
    if current_platform == "darwin":
        current_platform = "macos"
    
    target = args.platform or current_platform
    
    print(f"üöÄ {PROJECT_NAME} {VERSION} Build Script")
    print(f"   Current platform: {current_platform}")
    print(f"   Target platform: {target}")
    print()
    
    # Setup GitHub Actions if requested
    if args.setup_ci:
        setup_github_actions()
        return
    
    # Clean if requested
    if args.clean:
        clean_build_dirs()
    
    # Check dependencies
    if not check_dependencies():
        sys.exit(1)
    
    # Install requirements
    if not install_requirements():
        print("‚ö†Ô∏è Failed to install requirements, continuing anyway...")
    
    # Handle "all" platforms
    if target == "all":
        print("‚ö†Ô∏è Cross-platform builds work best with GitHub Actions")
        print("   Use --setup-ci to create the workflow, then push to GitHub")
        print("   Building for current platform only...")
        target = current_platform
    elif target != current_platform:
        print(f"‚ö†Ô∏è Cross-platform build requested ({target})")
        print(f"   Current platform is {current_platform}")
        print("   For reliable cross-platform builds, use GitHub Actions")
        print("   Continuing with target platform...")
    
    # Build executable
    if build_executable(target, args.spec_file):
        create_distribution_package(target)
        
        print()
        print("üéâ Build completed successfully!")
        print("üìÅ Check the ./releases/ folder for your executable")
        print()
        print("üöÄ Next steps:")
        print("   1. Test the executable on your target platform")
        print("   2. Use 'python build.py --setup-ci' to enable cross-platform builds")
        print("   3. Create a GitHub release for distribution") 
        print("   4. Share with your team!")
        
    else:
        print("‚ùå Build failed. Check error messages above.")
        sys.exit(1)

if __name__ == "__main__":
    main()
    
    print(f"üî® Building Research Buddy 3.1 for {target_platform}...")
    
    # Base PyInstaller command
    base_cmd = [
        "python", "-m", "PyInstaller",
        "--onefile",
        "--windowed", 
        "--distpath", "./dist",
        "--workpath", "./build",
        "--specpath", "./build"
    ]
    
    # Platform-specific settings
    if target_platform == "macos":
        cmd = base_cmd + [
            "--target-arch", "universal2",
            "--name", "ResearchBuddy3.1",
            "--osx-bundle-identifier", "edu.university.researchbuddy",
            "enhanced_training_interface.py"
        ]
    elif target_platform == "windows":
        cmd = base_cmd + [
            "--name", "ResearchBuddy3.1.exe",
            # "--icon", "app.ico",  # Add if you have an icon
            "enhanced_training_interface.py"
        ]
    else:  # linux
        cmd = base_cmd + [
            "--name", "ResearchBuddy3.1",
            "enhanced_training_interface.py"
        ]
    
    # Run PyInstaller
    cmd_str = " ".join(cmd)
    if run_command(cmd_str, f"Building {target_platform} executable"):
        print(f"üéâ Build completed for {target_platform}")
        
        # Show result
        dist_path = Path("./dist")
        if dist_path.exists():
            print(f"üì¶ Executable created in: {dist_path.absolute()}")
            for exe in dist_path.glob("*"):
                print(f"   üìÑ {exe.name} ({exe.stat().st_size // 1024} KB)")
        
        return True
    else:
        print(f"‚ùå Build failed for {target_platform}")
        return False

def create_distribution_package(target_platform=None):
    """Create distribution package with documentation"""
    if not target_platform:
        target_platform = platform.system().lower()
    
    print(f"üì¶ Creating distribution package for {target_platform}...")
    
    # Create distribution directory
    dist_dir = Path("./distribution")
    dist_dir.mkdir(exist_ok=True)
    
    platform_dir = dist_dir / f"ResearchBuddy3.1-{target_platform}"
    platform_dir.mkdir(exist_ok=True)
    
    # Copy executable
    dist_path = Path("./dist")
    for exe in dist_path.glob("*"):
        if exe.is_file():
            shutil.copy2(exe, platform_dir)
            print(f"   ‚úÖ Copied {exe.name}")
    
    # Copy documentation
    docs = [
        "README.md",
        "QUICK_REFERENCE.md", 
        "GA_TRAINING_GUIDE_3.0.md",
        "requirements.txt"
    ]
    
    for doc in docs:
        if Path(doc).exists():
            shutil.copy2(doc, platform_dir)
            print(f"   ‚úÖ Copied {doc}")
    
    # Create archive
    if target_platform == "windows":
        archive_name = f"ResearchBuddy3.0-{target_platform}"
        shutil.make_archive(str(dist_dir / archive_name), 'zip', platform_dir)
        print(f"   üì¶ Created {archive_name}.zip")
    else:
        archive_name = f"ResearchBuddy3.0-{target_platform}"
        shutil.make_archive(str(dist_dir / archive_name), 'gztar', platform_dir)
        print(f"   üì¶ Created {archive_name}.tar.gz")
    
    return True

def main():
    """Main build script"""
    target = sys.argv[1] if len(sys.argv) > 1 else None
    current_platform = platform.system().lower()
    
    print("üöÄ Research Buddy 3.1 Build Script")
    print(f"   Current platform: {current_platform}")
    print(f"   Target platform: {target or current_platform}")
    print()
    
    # Check dependencies
    if not check_dependencies():
        sys.exit(1)
    
    # Determine what to build
    if target == "all":
        print("‚ö†Ô∏è  Cross-platform builds require GitHub Actions")
        print("   Building for current platform only...")
        target = current_platform
    elif target and target != current_platform:
        print(f"‚ö†Ô∏è  Cross-platform build requested ({target})")
        print(f"   Current platform is {current_platform}")
        print("   For reliable cross-platform builds, use GitHub Actions")
        print("   Continuing with current platform...")
        target = current_platform
    
    target = target or current_platform
    
    # Build executable
    if build_executable(target):
        create_distribution_package(target)
        
        print()
        print("üéâ Build completed successfully!")
        print("üìÅ Check the ./distribution/ folder for your executable")
        print()
        print("üöÄ Next steps:")
        print("   1. Test the executable on your target platform")
        print("   2. Create a GitHub release for distribution") 
        print("   3. Share with your GA team!")
        
    else:
        print("‚ùå Build failed. Check error messages above.")
        sys.exit(1)

if __name__ == "__main__":
    main()